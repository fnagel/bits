(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{390:function(t,e,a){"use strict";a.r(e);var s=a(45),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"hot-reload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hot-reload"}},[t._v("#")]),t._v(" Hot Reload")]),t._v(" "),a("p",[t._v("If your module bundler supports hot reloading / hot module replacement (hmr), bits are ready for the task, too.")]),t._v(" "),a("p",[t._v("Hmr means, that when you edit the javascript source code of a bit, the instance on the site will be destroyed and recreated\nwithout reloading the entire page. This makes developing and testing your javascript code a lot faster.")]),t._v(" "),a("p",[a("img",{attrs:{src:"/hmr_bits.gif",alt:"Hot module replacement demo"}})]),t._v(" "),a("h2",{attrs:{id:"no-state-preservation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#no-state-preservation"}},[t._v("#")]),t._v(" No state preservation")]),t._v(" "),a("p",[t._v('In a framework like vue, where everything you do runs through a "renderer" state preservation is fairly easy to achieve,\nbits are working with the DOM directly, therefore there is no clear indicator on how the current state affects the DOM and vice verca.\nTherefore, when a bit is hot reloaded the current state will be dropped and reverted, back to the original.')]),t._v(" "),a("p",[t._v("This also means, that the HTML markdown of the bit mount will be reverted to the initial HTML state. This means all child-bits are recreated as well,\nso you can start with a blank state after the update.")]),t._v(" "),a("h2",{attrs:{id:"usage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usage"}},[t._v("#")]),t._v(" Usage")]),t._v(" "),a("p",[t._v("To use hot reload you must enable it on a per-bit level. To do this, simply use the "),a("code",[t._v("@Hot")]),t._v(" decorator on your bit class:")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("AbstractBit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Hot"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./AbstractBit'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Hot")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExampleBit")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbstractBit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ... your code here")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("What's module doing in there?")]),t._v(" "),a("p",[t._v('Yes, "module" is a global variable that gets provided by your module bundler (like webpack) and that bits uses to detect hot updates on a class.\n'),a("strong",[t._v("It is crucial, that you provide the module variable to @Hot, otherwise it will not work")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);